use crate::querybuilder::Selection;
use dagger_core::{Boolean, Int, Scalar};
use dagger_core::connect_params::ConnectParams;
use std::process::Child;
use std::sync::Arc;

// code generated by dagger. DO NOT EDIT.

/// A global cache volume identifier.
pub struct CacheID(Scalar);

/// A unique container identifier. Null designates an empty container (scratch).
pub struct ContainerID(Scalar);

/// A content-addressed directory identifier.
pub struct DirectoryID(Scalar);

/// A file identifier.
pub struct FileID(Scalar);

/// The platform config OS and architecture in a Container.
/// The format is [os]/[platform]/[version] (e.g. darwin/arm64/v7, windows/amd64, linux/arm64).
pub struct Platform(Scalar);

/// A unique identifier for a secret.
pub struct SecretID(Scalar);

/// A content-addressed socket identifier.
pub struct SocketID(Scalar);

/// 
pub struct BuildArg {
    pub name: String,

    pub value: String,
}


/// A directory whose contents persist across runs.
pub struct CacheVolume {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl CacheVolume {
    pub fn id(
        &self,
    ) -> CacheID {
        let query = self.selection.select("id");

        CacheID {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}

/// Initializes this container from a Dockerfile build, using the context, a dockerfile file path and some additional buildArgs.
pub struct BuildArgs {
    /// * `context` - Directory context used by the Dockerfile.
    pub context: DirectoryID,
    /// * `dockerfile` - Path to the Dockerfile to use.
    ///   Defaults to './Dockerfile'.
    pub dockerfile: Option<String>,
    /// * `buildArgs` - Additional build arguments.
    pub build_args: Option<Vec<BuildArg>>,
    /// * `target` - Target build stage to build.
    pub target: Option<String>,
}


/// Retrieves a directory at the given path. Mounts are included.
pub struct DirectoryArgs {
    pub path: String,
}


/// Retrieves the value of the specified environment variable.
pub struct EnvVariableArgs {
    pub name: String,
}


/// Retrieves this container after executing the specified command inside it.
pub struct ExecArgs {
    /// * `args` - Command to run instead of the container's default command.
    pub args: Option<Vec<String>>,
    /// * `stdin` - Content to write to the command's standard input before closing.
    pub stdin: Option<String>,
    /// * `redirectStdout` - Redirect the command's standard output to a file in the container.
    pub redirect_stdout: Option<String>,
    /// * `redirectStderr` - Redirect the command's standard error to a file in the container.
    pub redirect_stderr: Option<String>,
    /// * `experimentalPrivilegedNesting` - Provide dagger access to the executed command.
    ///   Do not use this option unless you trust the command being executed.
    ///   The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    pub experimental_privileged_nesting: Option<Boolean>,
}


/// Writes the container as an OCI tarball to the destination file path on the host for the specified platformVariants.
/// Return true on success.
pub struct ExportArgs {
    /// * `path` - Host's destination path.
    ///   Path can be relative to the engine's workdir or absolute.
    pub path: String,
    /// * `platformVariants` - Identifiers for other platform specific containers.
    ///   Used for multi-platform image.
    pub platform_variants: Option<Vec<ContainerID>>,
}


/// Retrieves a file at the given path. Mounts are included.
pub struct FileArgs {
    pub path: String,
}


/// Initializes this container from the base image published at the given address.
pub struct FromArgs {
    /// * `address` - Image's address from its registry.
    ///   Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
    pub address: String,
}


/// Retrieves the value of the specified label.
pub struct LabelArgs {
    pub name: String,
}


/// Creates a named sub-pipeline
pub struct PipelineArgs {
    pub name: String,
    pub description: Option<String>,
}


/// Publishes this container as a new image to the specified address, for the platformVariants, returning a fully qualified ref.
pub struct PublishArgs {
    /// * `address` - Registry's address to publish the image to.
    ///   Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
    pub address: String,
    /// * `platformVariants` - Identifiers for other platform specific containers.
    ///   Used for multi-platform image.
    pub platform_variants: Option<Vec<ContainerID>>,
}


/// Configures default arguments for future commands.
pub struct WithDefaultArgsArgs {
    pub args: Option<Vec<String>>,
}


/// Retrieves this container plus a directory written at the given path.
pub struct WithDirectoryArgs {
    pub path: String,
    pub directory: DirectoryID,
    pub exclude: Option<Vec<String>>,
    pub include: Option<Vec<String>>,
}


/// Retrieves this container but with a different command entrypoint.
pub struct WithEntrypointArgs {
    pub args: Vec<String>,
}


/// Retrieves this container plus the given environment variable.
pub struct WithEnvVariableArgs {
    pub name: String,
    pub value: String,
}


/// Retrieves this container after executing the specified command inside it.
pub struct WithExecArgs {
    /// * `args` - Command to run instead of the container's default command.
    pub args: Vec<String>,
    /// * `stdin` - Content to write to the command's standard input before closing.
    pub stdin: Option<String>,
    /// * `redirectStdout` - Redirect the command's standard output to a file in the container.
    pub redirect_stdout: Option<String>,
    /// * `redirectStderr` - Redirect the command's standard error to a file in the container.
    pub redirect_stderr: Option<String>,
    /// * `experimentalPrivilegedNesting` - Provide dagger access to the executed command.
    ///   Do not use this option unless you trust the command being executed.
    ///   The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    pub experimental_privileged_nesting: Option<Boolean>,
}


/// Initializes this container from this DirectoryID.
pub struct WithFsArgs {
    pub id: DirectoryID,
}


/// Retrieves this container plus the contents of the given file copied to the given path.
pub struct WithFileArgs {
    pub path: String,
    pub source: FileID,
    pub permissions: Option<Int>,
}


/// Retrieves this container plus the given label.
pub struct WithLabelArgs {
    pub name: String,
    pub value: String,
}


/// Retrieves this container plus a cache volume mounted at the given path.
pub struct WithMountedCacheArgs {
    pub path: String,
    pub cache: CacheID,
    pub source: Option<DirectoryID>,
}


/// Retrieves this container plus a directory mounted at the given path.
pub struct WithMountedDirectoryArgs {
    pub path: String,
    pub source: DirectoryID,
}


/// Retrieves this container plus a file mounted at the given path.
pub struct WithMountedFileArgs {
    pub path: String,
    pub source: FileID,
}


/// Retrieves this container plus a secret mounted into a file at the given path.
pub struct WithMountedSecretArgs {
    pub path: String,
    pub source: SecretID,
}


/// Retrieves this container plus a temporary directory mounted at the given path.
pub struct WithMountedTempArgs {
    pub path: String,
}


/// Retrieves this container plus a new file written at the given path.
pub struct WithNewFileArgs {
    pub path: String,
    pub contents: Option<String>,
    pub permissions: Option<Int>,
}


/// Initializes this container from this DirectoryID.
pub struct WithRootfsArgs {
    pub id: DirectoryID,
}


/// Retrieves this container plus an env variable containing the given secret.
pub struct WithSecretVariableArgs {
    pub name: String,
    pub secret: SecretID,
}


/// Retrieves this container plus a socket forwarded to the given Unix socket path.
pub struct WithUnixSocketArgs {
    pub path: String,
    pub source: SocketID,
}


/// Retrieves this containers with a different command user.
pub struct WithUserArgs {
    pub name: String,
}


/// Retrieves this container with a different working directory.
pub struct WithWorkdirArgs {
    pub path: String,
}


/// Retrieves this container minus the given environment variable.
pub struct WithoutEnvVariableArgs {
    pub name: String,
}


/// Retrieves this container minus the given environment label.
pub struct WithoutLabelArgs {
    pub name: String,
}


/// Retrieves this container after unmounting everything at the given path.
pub struct WithoutMountArgs {
    pub path: String,
}


/// Retrieves this container with a previously added Unix socket removed.
pub struct WithoutUnixSocketArgs {
    pub path: String,
}


/// An OCI-compatible container, also known as a docker container.
pub struct Container {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl Container {
    pub fn build(
        &self,
        args: &BuildArgs
    ) -> Container {
        let query = self.selection.select("build");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn default_args(
        &self,
    ) -> Option<Vec<String>> {
        let query = self.selection.select("defaultArgs");

        Option<Vec<String>> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn directory(
        &self,
        args: &DirectoryArgs
    ) -> Directory {
        let query = self.selection.select("directory");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn entrypoint(
        &self,
    ) -> Option<Vec<String>> {
        let query = self.selection.select("entrypoint");

        Option<Vec<String>> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn env_variable(
        &self,
        args: &EnvVariableArgs
    ) -> Option<String> {
        let query = self.selection.select("envVariable");
        query.args(args);

        Option<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn env_variables(
        &self,
    ) -> Vec<EnvVariable> {
        let query = self.selection.select("envVariables");

        Vec<EnvVariable> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn exec(
        &self,
        args: &ExecArgs
    ) -> Container {
        let query = self.selection.select("exec");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn exit_code(
        &self,
    ) -> Option<Int> {
        let query = self.selection.select("exitCode");

        Option<Int> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn export(
        &self,
        args: &ExportArgs
    ) -> Boolean {
        let query = self.selection.select("export");
        query.args(args);

        Boolean {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn file(
        &self,
        args: &FileArgs
    ) -> File {
        let query = self.selection.select("file");
        query.args(args);

        File {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn from(
        &self,
        args: &FromArgs
    ) -> Container {
        let query = self.selection.select("from");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn fs(
        &self,
    ) -> Directory {
        let query = self.selection.select("fs");

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn id(
        &self,
    ) -> ContainerID {
        let query = self.selection.select("id");

        ContainerID {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn label(
        &self,
        args: &LabelArgs
    ) -> Option<String> {
        let query = self.selection.select("label");
        query.args(args);

        Option<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn labels(
        &self,
    ) -> Vec<Label> {
        let query = self.selection.select("labels");

        Vec<Label> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn mounts(
        &self,
    ) -> Vec<String> {
        let query = self.selection.select("mounts");

        Vec<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn pipeline(
        &self,
        args: &PipelineArgs
    ) -> Container {
        let query = self.selection.select("pipeline");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn platform(
        &self,
    ) -> Platform {
        let query = self.selection.select("platform");

        Platform {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn publish(
        &self,
        args: &PublishArgs
    ) -> String {
        let query = self.selection.select("publish");
        query.args(args);

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn rootfs(
        &self,
    ) -> Directory {
        let query = self.selection.select("rootfs");

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn stderr(
        &self,
    ) -> Option<String> {
        let query = self.selection.select("stderr");

        Option<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn stdout(
        &self,
    ) -> Option<String> {
        let query = self.selection.select("stdout");

        Option<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn user(
        &self,
    ) -> Option<String> {
        let query = self.selection.select("user");

        Option<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_default_args(
        &self,
        args: &WithDefaultArgsArgs
    ) -> Container {
        let query = self.selection.select("withDefaultArgs");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_directory(
        &self,
        args: &WithDirectoryArgs
    ) -> Container {
        let query = self.selection.select("withDirectory");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_entrypoint(
        &self,
        args: &WithEntrypointArgs
    ) -> Container {
        let query = self.selection.select("withEntrypoint");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_env_variable(
        &self,
        args: &WithEnvVariableArgs
    ) -> Container {
        let query = self.selection.select("withEnvVariable");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_exec(
        &self,
        args: &WithExecArgs
    ) -> Container {
        let query = self.selection.select("withExec");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_fs(
        &self,
        args: &WithFsArgs
    ) -> Container {
        let query = self.selection.select("withFS");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_file(
        &self,
        args: &WithFileArgs
    ) -> Container {
        let query = self.selection.select("withFile");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_label(
        &self,
        args: &WithLabelArgs
    ) -> Container {
        let query = self.selection.select("withLabel");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_mounted_cache(
        &self,
        args: &WithMountedCacheArgs
    ) -> Container {
        let query = self.selection.select("withMountedCache");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_mounted_directory(
        &self,
        args: &WithMountedDirectoryArgs
    ) -> Container {
        let query = self.selection.select("withMountedDirectory");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_mounted_file(
        &self,
        args: &WithMountedFileArgs
    ) -> Container {
        let query = self.selection.select("withMountedFile");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_mounted_secret(
        &self,
        args: &WithMountedSecretArgs
    ) -> Container {
        let query = self.selection.select("withMountedSecret");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_mounted_temp(
        &self,
        args: &WithMountedTempArgs
    ) -> Container {
        let query = self.selection.select("withMountedTemp");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_new_file(
        &self,
        args: &WithNewFileArgs
    ) -> Container {
        let query = self.selection.select("withNewFile");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_rootfs(
        &self,
        args: &WithRootfsArgs
    ) -> Container {
        let query = self.selection.select("withRootfs");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_secret_variable(
        &self,
        args: &WithSecretVariableArgs
    ) -> Container {
        let query = self.selection.select("withSecretVariable");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_unix_socket(
        &self,
        args: &WithUnixSocketArgs
    ) -> Container {
        let query = self.selection.select("withUnixSocket");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_user(
        &self,
        args: &WithUserArgs
    ) -> Container {
        let query = self.selection.select("withUser");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_workdir(
        &self,
        args: &WithWorkdirArgs
    ) -> Container {
        let query = self.selection.select("withWorkdir");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn without_env_variable(
        &self,
        args: &WithoutEnvVariableArgs
    ) -> Container {
        let query = self.selection.select("withoutEnvVariable");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn without_label(
        &self,
        args: &WithoutLabelArgs
    ) -> Container {
        let query = self.selection.select("withoutLabel");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn without_mount(
        &self,
        args: &WithoutMountArgs
    ) -> Container {
        let query = self.selection.select("withoutMount");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn without_unix_socket(
        &self,
        args: &WithoutUnixSocketArgs
    ) -> Container {
        let query = self.selection.select("withoutUnixSocket");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn workdir(
        &self,
    ) -> Option<String> {
        let query = self.selection.select("workdir");

        Option<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}

/// Gets the difference between this directory and an another directory.
pub struct DiffArgs {
    pub other: DirectoryID,
}


/// Retrieves a directory at the given path.
pub struct DirectoryArgs {
    pub path: String,
}


/// Builds a new Docker container from this directory.
pub struct DockerBuildArgs {
    /// * `dockerfile` - Path to the Dockerfile to use.
    ///   Defaults to './Dockerfile'.
    pub dockerfile: Option<String>,
    /// * `platform` - The platform to build.
    pub platform: Option<Platform>,
    /// * `buildArgs` - Additional build arguments.
    pub build_args: Option<Vec<BuildArg>>,
    /// * `target` - Target build stage to build.
    pub target: Option<String>,
}


/// Returns a list of files and directories at the given path.
pub struct EntriesArgs {
    pub path: Option<String>,
}


/// Writes the contents of the directory to a path on the host.
pub struct ExportArgs {
    pub path: String,
}


/// Retrieves a file at the given path.
pub struct FileArgs {
    pub path: String,
}


/// load a project's metadata
pub struct LoadProjectArgs {
    pub config_path: String,
}


/// Creates a named sub-pipeline.
pub struct PipelineArgs {
    pub name: String,
    pub description: Option<String>,
}


/// Retrieves this directory plus a directory written at the given path.
pub struct WithDirectoryArgs {
    pub path: String,
    pub directory: DirectoryID,
    /// * `exclude` - Exclude artifacts that match the given pattern.
    ///   (e.g. ["node_modules/", ".git*"]).
    pub exclude: Option<Vec<String>>,
    /// * `include` - Include only artifacts that match the given pattern.
    ///   (e.g. ["app/", "package.*"]).
    pub include: Option<Vec<String>>,
}


/// Retrieves this directory plus the contents of the given file copied to the given path.
pub struct WithFileArgs {
    pub path: String,
    pub source: FileID,
    pub permissions: Option<Int>,
}


/// Retrieves this directory plus a new directory created at the given path.
pub struct WithNewDirectoryArgs {
    pub path: String,
    pub permissions: Option<Int>,
}


/// Retrieves this directory plus a new file written at the given path.
pub struct WithNewFileArgs {
    pub path: String,
    pub contents: String,
    pub permissions: Option<Int>,
}


/// Retrieves this directory with all file/dir timestamps set to the given time, in seconds from the Unix epoch.
pub struct WithTimestampsArgs {
    pub timestamp: Int,
}


/// Retrieves this directory with the directory at the given path removed.
pub struct WithoutDirectoryArgs {
    pub path: String,
}


/// Retrieves this directory with the file at the given path removed.
pub struct WithoutFileArgs {
    pub path: String,
}


/// A directory.
pub struct Directory {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl Directory {
    pub fn diff(
        &self,
        args: &DiffArgs
    ) -> Directory {
        let query = self.selection.select("diff");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn directory(
        &self,
        args: &DirectoryArgs
    ) -> Directory {
        let query = self.selection.select("directory");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn docker_build(
        &self,
        args: &DockerBuildArgs
    ) -> Container {
        let query = self.selection.select("dockerBuild");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn entries(
        &self,
        args: &EntriesArgs
    ) -> Vec<String> {
        let query = self.selection.select("entries");
        query.args(args);

        Vec<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn export(
        &self,
        args: &ExportArgs
    ) -> Boolean {
        let query = self.selection.select("export");
        query.args(args);

        Boolean {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn file(
        &self,
        args: &FileArgs
    ) -> File {
        let query = self.selection.select("file");
        query.args(args);

        File {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn id(
        &self,
    ) -> DirectoryID {
        let query = self.selection.select("id");

        DirectoryID {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn load_project(
        &self,
        args: &LoadProjectArgs
    ) -> Project {
        let query = self.selection.select("loadProject");
        query.args(args);

        Project {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn pipeline(
        &self,
        args: &PipelineArgs
    ) -> Directory {
        let query = self.selection.select("pipeline");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_directory(
        &self,
        args: &WithDirectoryArgs
    ) -> Directory {
        let query = self.selection.select("withDirectory");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_file(
        &self,
        args: &WithFileArgs
    ) -> Directory {
        let query = self.selection.select("withFile");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_new_directory(
        &self,
        args: &WithNewDirectoryArgs
    ) -> Directory {
        let query = self.selection.select("withNewDirectory");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_new_file(
        &self,
        args: &WithNewFileArgs
    ) -> Directory {
        let query = self.selection.select("withNewFile");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_timestamps(
        &self,
        args: &WithTimestampsArgs
    ) -> Directory {
        let query = self.selection.select("withTimestamps");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn without_directory(
        &self,
        args: &WithoutDirectoryArgs
    ) -> Directory {
        let query = self.selection.select("withoutDirectory");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn without_file(
        &self,
        args: &WithoutFileArgs
    ) -> Directory {
        let query = self.selection.select("withoutFile");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}


/// A simple key value object that represents an environment variable.
pub struct EnvVariable {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl EnvVariable {
    pub fn name(
        &self,
    ) -> String {
        let query = self.selection.select("name");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn value(
        &self,
    ) -> String {
        let query = self.selection.select("value");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}

/// Writes the file to a file path on the host.
pub struct ExportArgs {
    pub path: String,
}


/// Retrieves this file with its created/modified timestamps set to the given time, in seconds from the Unix epoch.
pub struct WithTimestampsArgs {
    pub timestamp: Int,
}


/// A file.
pub struct File {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl File {
    pub fn contents(
        &self,
    ) -> String {
        let query = self.selection.select("contents");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn export(
        &self,
        args: &ExportArgs
    ) -> Boolean {
        let query = self.selection.select("export");
        query.args(args);

        Boolean {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn id(
        &self,
    ) -> FileID {
        let query = self.selection.select("id");

        FileID {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn secret(
        &self,
    ) -> Secret {
        let query = self.selection.select("secret");

        Secret {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn size(
        &self,
    ) -> Int {
        let query = self.selection.select("size");

        Int {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn with_timestamps(
        &self,
        args: &WithTimestampsArgs
    ) -> File {
        let query = self.selection.select("withTimestamps");
        query.args(args);

        File {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}

/// The filesystem tree at this ref.
pub struct TreeArgs {
    pub ssh_known_hosts: Option<String>,
    pub ssh_auth_socket: Option<SocketID>,
}


/// A git ref (tag, branch or commit).
pub struct GitRef {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl GitRef {
    pub fn digest(
        &self,
    ) -> String {
        let query = self.selection.select("digest");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn tree(
        &self,
        args: &TreeArgs
    ) -> Directory {
        let query = self.selection.select("tree");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}

/// Returns details on one branch.
pub struct BranchArgs {
    pub name: String,
}


/// Returns details on one commit.
pub struct CommitArgs {
    pub id: String,
}


/// Returns details on one tag.
pub struct TagArgs {
    pub name: String,
}


/// A git repository.
pub struct GitRepository {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl GitRepository {
    pub fn branch(
        &self,
        args: &BranchArgs
    ) -> GitRef {
        let query = self.selection.select("branch");
        query.args(args);

        GitRef {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn branches(
        &self,
    ) -> Vec<String> {
        let query = self.selection.select("branches");

        Vec<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn commit(
        &self,
        args: &CommitArgs
    ) -> GitRef {
        let query = self.selection.select("commit");
        query.args(args);

        GitRef {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn tag(
        &self,
        args: &TagArgs
    ) -> GitRef {
        let query = self.selection.select("tag");
        query.args(args);

        GitRef {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn tags(
        &self,
    ) -> Vec<String> {
        let query = self.selection.select("tags");

        Vec<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}

/// Accesses a directory on the host.
pub struct DirectoryArgs {
    pub path: String,
    pub exclude: Option<Vec<String>>,
    pub include: Option<Vec<String>>,
}


/// Accesses an environment variable on the host.
pub struct EnvVariableArgs {
    pub name: String,
}


/// Accesses a Unix socket on the host.
pub struct UnixSocketArgs {
    pub path: String,
}


/// Retrieves the current working directory on the host.
pub struct WorkdirArgs {
    pub exclude: Option<Vec<String>>,
    pub include: Option<Vec<String>>,
}


/// Information about the host execution environment.
pub struct Host {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl Host {
    pub fn directory(
        &self,
        args: &DirectoryArgs
    ) -> Directory {
        let query = self.selection.select("directory");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn env_variable(
        &self,
        args: &EnvVariableArgs
    ) -> Option<HostVariable> {
        let query = self.selection.select("envVariable");
        query.args(args);

        Option<HostVariable> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn unix_socket(
        &self,
        args: &UnixSocketArgs
    ) -> Socket {
        let query = self.selection.select("unixSocket");
        query.args(args);

        Socket {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn workdir(
        &self,
        args: &WorkdirArgs
    ) -> Directory {
        let query = self.selection.select("workdir");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}


/// An environment variable on the host environment.
pub struct HostVariable {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl HostVariable {
    pub fn secret(
        &self,
    ) -> Secret {
        let query = self.selection.select("secret");

        Secret {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn value(
        &self,
    ) -> String {
        let query = self.selection.select("value");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}


/// A simple key value object that represents a label.
pub struct Label {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl Label {
    pub fn name(
        &self,
    ) -> String {
        let query = self.selection.select("name");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn value(
        &self,
    ) -> String {
        let query = self.selection.select("value");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}


/// A set of scripts and/or extensions
pub struct Project {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl Project {
    pub fn extensions(
        &self,
    ) -> Option<Vec<Project>> {
        let query = self.selection.select("extensions");

        Option<Vec<Project>> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn generated_code(
        &self,
    ) -> Directory {
        let query = self.selection.select("generatedCode");

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn install(
        &self,
    ) -> Boolean {
        let query = self.selection.select("install");

        Boolean {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn name(
        &self,
    ) -> String {
        let query = self.selection.select("name");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn schema(
        &self,
    ) -> Option<String> {
        let query = self.selection.select("schema");

        Option<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn sdk(
        &self,
    ) -> Option<String> {
        let query = self.selection.select("sdk");

        Option<String> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}

/// Constructs a cache volume for a given cache key.
pub struct CacheVolumeArgs {
    /// * `key` - A string identifier to target this cache volume (e.g. "myapp-cache").
    pub key: String,
}


/// Loads a container from ID.
/// Null ID returns an empty container (scratch).
/// Optional platform argument initializes new containers to execute and publish as that platform. Platform defaults to that of the builder's host.
pub struct ContainerArgs {
    pub id: Option<ContainerID>,
    pub platform: Option<Platform>,
}


/// Load a directory by ID. No argument produces an empty directory.
pub struct DirectoryArgs {
    pub id: Option<DirectoryID>,
}


/// Loads a file by ID.
pub struct FileArgs {
    pub id: FileID,
}


/// Queries a git repository.
pub struct GitArgs {
    pub url: String,
    pub keep_git_dir: Option<Boolean>,
}


/// Returns a file containing an http remote url content.
pub struct HttpArgs {
    pub url: String,
}


/// Creates a named sub-pipeline
pub struct PipelineArgs {
    pub name: String,
    pub description: Option<String>,
}


/// Look up a project by name
pub struct ProjectArgs {
    pub name: String,
}


/// Loads a secret from its ID.
pub struct SecretArgs {
    pub id: SecretID,
}


/// Loads a socket by its ID.
pub struct SocketArgs {
    pub id: Option<SocketID>,
}


/// 
pub struct Query {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl Query {
    pub fn cache_volume(
        &self,
        args: &CacheVolumeArgs
    ) -> CacheVolume {
        let query = self.selection.select("cacheVolume");
        query.args(args);

        CacheVolume {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn container(
        &self,
        args: &ContainerArgs
    ) -> Container {
        let query = self.selection.select("container");
        query.args(args);

        Container {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn default_platform(
        &self,
    ) -> Platform {
        let query = self.selection.select("defaultPlatform");

        Platform {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn directory(
        &self,
        args: &DirectoryArgs
    ) -> Directory {
        let query = self.selection.select("directory");
        query.args(args);

        Directory {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn file(
        &self,
        args: &FileArgs
    ) -> Option<File> {
        let query = self.selection.select("file");
        query.args(args);

        Option<File> {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn git(
        &self,
        args: &GitArgs
    ) -> GitRepository {
        let query = self.selection.select("git");
        query.args(args);

        GitRepository {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn host(
        &self,
    ) -> Host {
        let query = self.selection.select("host");

        Host {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn http(
        &self,
        args: &HttpArgs
    ) -> File {
        let query = self.selection.select("http");
        query.args(args);

        File {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn pipeline(
        &self,
        args: &PipelineArgs
    ) -> Query {
        let query = self.selection.select("pipeline");
        query.args(args);

        Query {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn project(
        &self,
        args: &ProjectArgs
    ) -> Project {
        let query = self.selection.select("project");
        query.args(args);

        Project {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn secret(
        &self,
        args: &SecretArgs
    ) -> Secret {
        let query = self.selection.select("secret");
        query.args(args);

        Secret {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn socket(
        &self,
        args: &SocketArgs
    ) -> Socket {
        let query = self.selection.select("socket");
        query.args(args);

        Socket {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}


/// A reference to a secret value, which can be handled more safely than the value itself.
pub struct Secret {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl Secret {
    pub fn id(
        &self,
    ) -> SecretID {
        let query = self.selection.select("id");

        SecretID {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }

    pub fn plaintext(
        &self,
    ) -> String {
        let query = self.selection.select("plaintext");

        String {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}


/// 
pub struct Socket {
    pub conn: ConnectParams,
    pub proc: Arc<Child>,
    pub selection: Selection,
}

impl Socket {
    pub fn id(
        &self,
    ) -> SocketID {
        let query = self.selection.select("id");

        SocketID {
            conn: self.conn.clone(),
            proc: self.proc.clone(),
            selection: query,
        }
    }
}
